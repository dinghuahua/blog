强缓存 协议缓存
## 本文提纲包含以下内容：
* 区分进程和线程
* 浏览器包含哪些进程
* 渲染进程（或者经常称为Render进程或者浏览器内核）包含哪些主要线程
    * 浏览器内核中包含的线程之间的关系
    * browser进程和浏览器内核的通信过程
    * 渲染进程是如何工作的
    * GUI渲染线程和js线程（或者经常称为js引擎）的互斥关系
    * js 阻塞页面加载
    * 页面卡顿的真正原因
    * 为什么JavaScript 是单线程的？
    * WebWorker 与 SharedWork
* 地址栏回车后的所有一系列的过程分析（牵扯到浏览器顶层的部分不必死磕）
* css加载是否会阻塞dom树渲染？
* 普通图层和复合图层以及CSS动画 和js 实现动画的性能对比
* 从Event Loop 谈JS的运行机制以及 从 macrotask 和 microtask 谈Event Loop 
* 从帧(16.6ms优化)的角度分析浏览器空闲时间
* 首屏加载时间是从哪一步到哪一步
* 结合帧的角度和时间性能的角度分析CSS动画 和js 实现的动画
* 在浏览器空闲时间和渲染前等时间段分析requestIdleCallback 和 requestAnimationFrame 这两个方法
* 结合React 16 中的fiber 分析浏览器空闲时间执行的requestIdleCallback

## 区分进程和线程
1. 进程是CPU资源分配的最小单位（是能拥有资源和独立运行的最小单位）
2. 线程是CPU调度的最小单位（线程是建立在进程的基础上的一次程序运行单位，一个进程可以有多个线程）
注意：
* 不同进程之间也可以通信，不过代价较大
* 现在一般通用的叫法：单线程和多线程，都是指在一个进程内的单和多

## 浏览器包含哪些进程
* 浏览器是多进程的
* 浏览器之所以能够运行，是因为系统给它的进程分配了资源（cpu和内存）
* 简单理解，每打开一个tab页，就相当于创建了一个独立的浏览器进程，可以通过打开任务管理器仅从查看验证,也可以通过Chrome的更多工具-> 任务管理器进行验证
<div align='center'>
<image src='https://github.com/dinghuahua/blog/blob/feature1/browser/images/browser1.png' width=50%>
<image src='https://github.com/dinghuahua/blog/blob/feature1/browser/images/browser2.png' width=50%>
</div>

注意：
1. 在这里浏览器应该有自己的优化机制，有时候打开多个tab页后，可以在Chrome任务管理器中看到，但有些进程被合并了（所以每一个tab标签对应一个进程并不一定是绝对的）
2. 浏览器多进程

优点： 1.某一渲染进程出问题不会影响其他的进程
      2.更为安全，在系统层面上限定了不同进程的权限 
      3.避免单个page crash 或者第三方插件影响整个浏览器
      4.多进程充分利用多核优势
      5.方便使用沙盒模型隔离插件等进程，提高浏览器稳定性

到底包含了哪些进程（为了简化理解，仅列举主要进程）
    Browser进程：也称为主控进程、主进程，浏览器的主要进程（负责协调、主控），只有一个，
        作用如下（了解，不必死磕）
            * 包括地址栏，书签栏
            * 负责浏览器的一些不可见的底层操作，比如网络请求和文件访问等
            * 负责浏览器与用户的交互，如前进。后退等
            * 将页面绘制出来
            * 负责各个页面的管理、创建和销毁其他进程等
            * 将Render进程得到的内存中的Bitmap绘制到用户界面上
            * 网络资源的管理，下载等
        我们知道浏览器 Tab 外的工作主要由 Browser Process 掌控，Browser Process 又对这些工作进一步划分，使用不同线程进行处理：  
            * UI thread ： 控制浏览器上的按钮及输入框；
            * network thread: 处理网络请求，从网上获取数据；storage 
            * thread: 控制文件等的访问；

    第三方插件进程：每种类型的插件对应一个进程，仅当使用该插件时才创建

    GPU进程：最多一个，用于3D绘制和显示页面，处理和渲染图形
        内部也有合成器
        GPU合成没有官方规范，每个浏览器的问题和解决方式也不同；
        仅当GPU硬件加速打开的时候才会被创建，主要用于对3D图形加速调用的实现（联想css动画和js动画性能对比）； 

    浏览器渲染进程(浏览器内核、Render进程、呈现引擎)：内部是多线程，默认每个Tab页面是一个进程，互不影响，以下是主要的线程：
        排版线程 compositor thread  合成器将页面分成磁贴，
        光栅线程 Raster thread      栅格线程格化磁贴存储在GPU显存中
        GUI线程
            * 负责渲染浏览器界面，解析html css 构建DOM书和RenderObject树，布局和绘制等
            * 当界面需要重绘Repaint或者由于某种操作引发的回流reflow，该线程就会执行
            * 注意，GUI 渲染线程和JS引擎线程是互斥的，当JS引擎执行时GUI线程会被挂起（相当于被冻结），GUI更新会被保存在一个队列中等待JS引擎空闲时立即被执行。（联想requestIdleCallback回掉执行的时间超时影响的后果）
        JS引擎线程
            * 也称为JavaScript解释器、JS内核，负责处理javascript脚本程序（例如V8引擎）
            * 解释器、编译器的区别，解释器是直接解析并将代码运行结果输出
            * JS引擎线程负责解析JavaScript脚本，运行代码
            * 一个Tab页（Render进程）中无论什么时候都只有一个JS线程在运行JS程序
            * 注意，GUI 渲染线程和JS引擎线程是互斥的，所以JS引擎执行时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞。（联想requestIdleCallback回掉执行的时间超时影响的后果）
            * 内部在维护一个任务队列
        事件触发线程
            * 归属于浏览器内核而不是JS引擎，用来控制事件循环
            * 当JS引擎执行代码如setTimeOut或者来自浏览器内核的其他线程，如鼠标点击、AJAX异步请求等，会将对应任务添加到事件线程中
            * 当对应的事件符合触发条件时，该线程会把事件添加到待处理队列的队尾，等待JS引擎的处理
            * 注意，由于JS引擎的单线程的关系，所以这些待处理队列中的事件都等排队等待JS引擎的处理，当JS引擎空闲时才会去执行
        定时器触发线程
            * setTimeOut 和 setInterval 所在的线程
            * 浏览器定时计数器并不是由JS引擎计数的，因为JS引擎是单线程的，如果处于阻塞线程状态就会影响计时的准确性
            * 因此通过单独的线程来计时并触发定时，计时完毕后，添加到事件队列中，等待JS引擎空闲后执行
            * 注意，W3C HTMl 标准中规定，规定要求setTimeOut 中低于4ms 的时间间隔算为4ms
        Networking 异步http请求线程
            * 在XMLHttpRequest 在连接后是通过浏览器新开一个线程请求
            * 检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更事件，将这个回调再放入事件队列中，再由JS引擎执行

<div align='center'>
<image src='https://github.com/dinghuahua/blog/blob/feature1/browser/images/browser5.png'>
</div>
> 浏览器帧原理剖析
>> 进程
* 渲染进程。包裹标签页的容器。包含了多个线程，这些线程一起负责了页面显示到屏幕上的各个方面。这些线程有合成线程（Compositor），图块栅格化线程（Tile Worker），和主线程。
* GPU 进程。这是一个单一的进程，为所有标签页和浏览器周边进程服务。当帧被提交时，GPU 进程会将分为图块的位图和其他数据（比如四边形顶点和矩阵）上传到 GPU 中，真正将像素显示到屏幕上。GPU 进程只有一个的线程，叫 GPU 线程，实际上是它做了这些工作。
>> 渲染进程中的线程
<div align='center'>
<image src='https://github.com/dinghuahua/blog/blob/feature1/browser/images/browser4.svg'>
</div>

* 合成线程（Compositor Thread）。这是最先被告知垂直同步事件（vsync event，操作系统告知浏览器刷新一帧图像的信号）的线程。它接收所有的输入事件。如果可能，合成线程会避免进入主线程，自己尝试将输入的事件（比如滚动）转换为屏幕的移动。它会更新图层的位置，并经由 GPU 线程直接向 GPU 提交帧来完成这个操作。如果输入事件需要进行处理，或者有其他的显示工作，它将无法直接完成该过程，这就需要主线程了。
* 主线程。在这里浏览器执行我们熟知和喜欢的那些任务：JavaScript，样式，布局和绘制。（这一点以后会变化，有了 Houdini，我们可以在合成线程中运行一些代码）主线程荣获“最容易导致 jank 奖”，很大程度上是因为它要做的事情太多了这个事实。（译注：jank 指页面内容抖动卡顿，由于页面内容的更新频率跟不上屏幕刷新频率导致）
* 合成图块栅格化线程（Compositor Tile Worker）。由合成线程派生的一个或多个线程，用于处理栅格化任务。我们稍后再讨论。
* 在许多方面，你都应该把合成线程看做“老大”。虽然这个线程不运行 JavaScript，不进行布局、绘制内容或者其他任务，但是它全权负责启动主线程工作，并将帧运送到屏幕上。如果合成线程不用等待输入事件的处理，就可以在等待主线程完成工作时把帧发送出去。
* 你也可以想象 Service Worker 和 Web Worker 存在于渲染进程中，虽然我把他们排除在外了，因为他们把事情弄得很复杂。
>> 运作过程
让我们从垂直同步信号到像素，逐步分析这个过程，然后讨论一下在完全版本中事件是怎么工作的。记住这一点：浏览器并不需要执行所有步骤，具体情况取决于哪些步骤是必需的。例如，如果没有新的 HTML 要解析，那么解析 HTML 的步骤就不会触发。事实上，通常提升性能的最佳方法，只是简单地移除流程中部分步骤被触发的需要！
同样值得注意的是，上图中 RecalcStyles 和 Layout 下方指向 requestAnimationFrame 的红色箭头。在代码中恰好触发这两个情况是完全可能的。这种情况叫做强制同步布局（或强制同步样式，Forced Synchronous Layout 和 Forced Synchronous Styles），通常于性能不利。

* 开始新的一帧。垂直同步信号触发，开始渲染新的一帧图像。

* 输入事件的处理。从合成线程将输入的数据，传递到主线程的事件处理函数。所有的事件处理函数（touchmove，scroll，click）都应该最先触发，每帧触发一次，但也不一定这样；调度程序会尽力尝试，但是是否真的每帧触发因操作系统而异。从用户交互事件，到事件被交付主线程，二者之间也存在延迟。

* requestAnimationFrame。这是更新屏幕显示内容的理想位置，因为现在有全新的输入数据，又非常接近即将到来的垂直同步信号。其他的可视化任务，比如样式计算，因为是在本次任务之后，所以现在是变更元素的理想位置。如果你改变了 —— 比如说 100 个类的样式，这不会引起 100 次样式计算；它们会在稍后被批量处理。唯一需要注意的是，不要查询进行计算才能得到的样式或者布局属性（比如 el.style.backgroundImage 或 el.style.offsetWidth）。如果你这样做了，会导致重新计算样式，或者布局，或者二者都发生，进一步导致强制同步布局，乃至布局颠簸。

* 解析 HTML（Parse HTML）。处理新添加的 HTML，创建 DOM 元素。在页面加载过程中，或者进行 appendChild 操作后，你可能看到更多的此过程发生。

* 重新计算样式（Recalc Styles）。为新添加或变更的内容计算样式。可能要计算整个 DOM 树，也可能缩小范围，取决于具体更改了什么。例如，更改 body 的类名影响可能很大，但是值得注意的是浏览器已经足够智能了，可以自动限制重新计算样式的范围。

* 布局（Layout）。计算每个可见元素的几何信息（每个元素的位置和大小）。一般作用于整个文档，计算成本通常和 DOM 元素的大小成比例。

* 更新图层树（Update Layer Tree）。这一步创建层叠上下文，为元素的深度进行排序。

* Paint。过程分为两步：第一步，对所有新加入的元素，或进行改变显示状态的元素，记录 draw 调用（这里填充矩形，那里写点字）；第二步是栅格化（Rasterization，见后文），在这一步实际执行了 draw 的调用，并进行纹理填充。Paint 过程记录 draw 调用，一般比栅格化要快，但是两部分通常被统称为“painting”。

* 合成（Composite）：图层和图块信息计算完成后，被传回合成线程进行处理。这将包括 will-change、重叠元素和硬件加速的 canvas 等。

* 栅格化规划（Raster Scheduled）和栅格化（Rasterize）：在 Paint 任务中记录的 draw 调用现在执行。过程是在合成图块栅格化线程（Compositor Tile Workers）中进行，线程的数量取决于平台和设备性能。例如，在 Android 设备上，通常有一个线程，而在桌面设备上有时有 4 个。栅格化根据图层来完成，每层都被分成块。

* 帧结束：各个层的所有的块都被栅格化成位图后，新的块和输入数据（可能在事件处理程序中被更改过）被提交给 GPU 线程。

* 发送帧：最后，但同样很重要的是，图块被 GPU 线程上传到 GPU。GPU 使用四边形和矩阵（所有常用的 GL 数据类型）将图块 draw 在屏幕上。

* requestIdleCallback：如果在帧结束时，主线程还有点时间，requestIdleCallback 可能会被触发。这是做些非必要工作的好机会，比如标记分析数据。

>> 在工作流程中深度的排序有两种版本。
* 首先是层叠上下文，比如有 2 个绝对定位的重叠的 div。更新图层树（Update Layer Tree） 是流程的一部分，保证 z-index 和类似的属性受到重视。
* 然后是合成图层，在上述流程较后的位置，多用于绘制元素。可以使用空 transform 技巧（译注：指使用 translateZ(0,0) 强制开启硬件加速），或者 will-change: transform 将一个元素提升为合成图层，这样就能轻松地使用 transform 动画（有利于动画效果！）。但是如果存在重叠元素，浏览器也可能需要创建额外的合成图层，来保持由 z-index 或者其他属性指定的深度顺序。有趣！

>> GPU
实质上，上面概述的过程都是在 CPU 中完成的。只有最后一部分，图块被上传和移动的过程，是在 GPU 中完成的。
然而，在 Android 上，像素流在栅格化时有所不同：GPU 用得更多一些。在 GPU 着色器上用 GL 命令执行 draw 调用，而不是在合成图块栅格化线程中进行栅格化。
这就是所谓的 GPU 栅格化，是一种降低绘制（paint）成本的方法。在 Chrome DevTools 中启用 FPS Meter（FPS 计数），你可以查看页面是否使用了 GPU 栅格化。


[链接：https://juejin.im/post/5c9c66075188251dab07413d](https://juejin.im/post/5c9c66075188251dab07413d)

> browser进程和Renderer进程（浏览器内核）的通信过程

    1. Browser进程收到用户请求，首先UI线程处理，转交给IO线程，随后通过RendererHost接口转交给Renderer进程
    2. Renderer进程的Renderer接口收到消息，IO线程简单处理后，交给渲染线程，进行HTML解析和DOM树构建，CSS解析，JS执行，RenderObject树构建，布局和绘制等过程，生成用户可见区域（ViewPort）的Bitmap。最后通过共享内存方式IPC给Browser进程
    3. Browser进程使用Bitmap内存在界面上绘制出图像。
   
> 渲染进程是如何工作的

>> 在从服务器中拿到数据后，浏览器会先做解析三类东西：

 * 解析html,xhtml,svg这三类文档，形成dom树。
 * 解析css，产生css rule tree。
 * 解析js，js会通过api来操作dom tree和css rule tree。
 * 解析完成之后，浏览器引擎会通过dom tree和css rule tree来构建rendering tree：
 * rendering tree和dom tree并不完全相同，例如：<head></head>或display:none的东西就不会放在渲染树中。
 * css rule tree主要是完成匹配，并把css rule附加给rendering tree的每个element。
 * 在渲染树构建完成后，
 * 浏览器会对这些元素进行定位和布局，这一步也叫做reflow或者layout。
 * 浏览器绘制这些元素的样式，颜色，背景，大小及边框等，这一步也叫做repaint。
 * 然后浏览器会将各层的信息发送给GPU，GPU会将各层合成；显示在屏幕上。

>> 渲染进程的核心目的在于转换HTML CSS JS 为用户可交互的web页面

    解析DOM树 构建 DOM树 CSS加载解析，
    JS执行
    RenderObject树构建
    layout  布局 回流reflow  ->布局树 只包含页面可见元素
    paint   绘制 重绘 repaint ->绘制记录
    合成帧   优点：其工作无关主线程
        排版线程 compositor thread  合成器将页面分成磁贴，
            合成器的优点在于，其工作无关主线程，合成器线程不需要等待样式计算或者 JS 执行，这就是为什么合成器相关的动画 最流畅，如果某个动画涉及到布局或者绘制的调整，就会涉及到主线程的重新计算，自然会慢很多。
        光栅线程 Raster thread      栅格线程格化磁贴存储在GPU显存中（享内存）
        一旦磁贴被光栅化，合成器线程会收集称为绘制四边形的磁贴信息以创建合成帧（Bitmap）。
不同呈现引擎在主流程中会有稍微不同，例如css样式表的解析时机，在webkit 内核 html和css 的解析是同步的

事件循环
> GUI渲染线程与JS引擎线程互斥
1. 由于JavaScript是可操作DOM的，如果在修改这些元素属性同时渲染界面（即JS线程和UI线程同时运行）那么渲染线程前后获得的元素数据就可能不一致来
2. 因此为了防止渲染出现不可预期的结果，浏览器设置GUI渲染线程与JS引擎为互斥关系，当JS引擎执行时GUI线程会被挂起，GUI更新则会被保存在一个队列中等待JS引擎线程空闲时立即被执行
> JS阻塞页面加载
1. 从上述的互斥关系，可以推导出，如果JS执行时间过长就会阻塞页面。
2. 譬如，假设JS引擎正在进行巨量计算，此时就算GUI有更新，也会被保存到队列中，等待JS引擎空闲后执行，然后由于巨量计算，随意JS引擎很可能很久之后才能空闲，自然会感觉到巨卡无比，所以，要尽量避免JS执行时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞的感觉（联想requestIdleCallback回掉执行的时间超时影响的后果）
> 页面卡顿的真正原因
1. 由于 JavaScript 是可操纵 DOM 的，如果在修改这些元素属性同时渲染界面（即 JavaScript 线程和 UI 线程同时运行），那么渲染线程前后获得的元素数据就可能不一致了。为了防止渲染出现不可预期的结果，浏览器设置 UI 渲染线程与 JavaScript 引擎线程为互斥的关系，当 JavaScript 引擎线程执行时 UI 渲染线程会被挂起，UI 更新会被保存在一个队列中等到 JavaScript 引擎线程空闲时立即被执行。

2. 于是，我们便明白了：假设一个 JavaScript 代码执行的时间过长，这样就会造成页面的渲染不连贯，导致页面渲染出现“加载阻塞”的现象。当然，针对 DOM 的大量操作也会造成页面出现卡顿现象，毕竟我们经常说：DOM 天生就很慢。

3. 所以，当你需要考虑性能优化时就可以从如上的原因出发，大致有以下几个努力的方面：
    * 减少 JavaScript 加载对 DOM 渲染的影响（将 JavaScript 代码的加载逻辑放在 HTML 文件的尾部，减少对渲染引擎呈现工作的影响）；
    * 避免重排，减少重绘（避免白屏，或者交互过程中的卡顿）；
    * 减少 DOM 的层级（可以减少渲染引擎工作过程中的计算量）；
    * 使用 requestAnimationFrame 来实现视觉变化（一般来说我们会使用 setTimeout 或 setInterval 来执行动画之类的视觉变化，但这种做法的问题是，回调将在帧中的某个时点运行，可能刚好在末尾，而这可能经常会使我们丢失帧，导致卡顿）；
    有关优化的方面可以查看《 优化 JavaScript 执行》一文了解更多信息。
> 为什么JavaScript 是单线程的？
否则会带来很复杂的同步问题，比如，假定 JavaScript 同时有两个线程，一个线程在某个 DOM 节点上添加内容，另一个线程删除了这个节点，这时浏览器应该以哪个线程为准？当然我们可以通过锁来解决上面的问题。但为了避免因为引入了锁而带来更大的复杂性，从一诞生，JavaScript 就是单线程，这已经成了这门语言的核心特征。
> WebWorker 与 SharedWork
为了利用多核 CPU 的计算能力，在 HTML5 中引入的工作线程使得浏览器端的 JavaScript 引擎可以并发地执行 JavaScript 代码，从而实现了对浏览器端多线程编程的良好支持。Web Worker 允许 JavaScript 脚本创建多个线程，但是子线程完全受主线程控制，且不得操作 DOM 。所以，这个新标准并没有改变 JavaScript 单线程的本质。
1. 前文提到提到的JS引擎是单线程的，而且JS执行时间过长会阻塞页面，那么JS就真的对CPU密集型计算无能为力吗？所以后来HTML5中支持来Web Worker
2. MDN 官方解释：
    Web Worker为Web内容在后台线程中运行脚本提供了一种简单的方法。线程可以执行任务而不干扰用户界面，一个worker是使用一个构造函数创建的一个对象(eg:Worker()) 运行一个命名的JavaScript文件,这个文件包含将在工作线程中运行的代码; workers 运行在另一个全局上下文中,不同于当前的window,因此，使用 window快捷方式获取当前全局的范围 (而不是self) 在一个 Worker 内将返回错误
3. JS引擎线程与worker线程间通过特定的方式通信（postMessage API，需要通过序列化对象来与线程交互特定的数据）,相当于给JS引擎开了一个外挂
4. 所以如果有非常耗时的工作，单独开一个Worker线程，这样里面不管如何都不会影响JS引擎线程，只等待出结果后，将结果通信给S引擎线程即可
5. WebWorker只属于某个页面，不会和其他页面的Render进程（浏览器内核进程）共享
6. 所以Chrome在Render进程中（每一个Tab页就是一个render进程）创建一个新的线程来运行Worker中的JavaScript程序。
7. SharedWorker是浏览器所有页面共享的，不能采用与Worker同样的方式实现，因为它不隶属于某个Render进程，可以为多个Render进程共享使用
8. 所以Chrome浏览器为SharedWorker单独创建一个进程来运行JavaScript程序，在浏览器中每个相同的JavaScript只存在一个SharedWorker进程，不管它被创建多少次。
看到这里，应该就很容易明白了，本质上就是进程和线程的区别。SharedWorker由独立的进程管理，WebWorker只是属于render进程下的一个线程

## 地址栏回车后的所有一系列的过程分析（牵扯到浏览器顶层的部分不必死磕）
    大多数人使用 Chrome 最多的场景就是在地址栏输入关键字进行搜索或者输入地址导航到某个网站，我们来看看浏览器是怎么看待这个过程的。
参考连接：https://www.jianshu.com/p/5a52f2492759
## css加载是否会阻塞dom树渲染？
这里说的是头部引入css的情况
首先，我们都知道：css是由单独的下载线程异步下载的。
然后再说下几个现象：
    1. css加载不会阻塞DOM树解析（异步加载时DOM照常构建）
    2. 但会阻塞render树渲染（渲染时需等css加载完毕，因为render树需要css信息）
这可能也是浏览器的一种优化机制。
因为你加载css的时候，可能会修改下面DOM节点的样式，
如果css加载不阻塞render树渲染的话，那么当css加载完之后，
render树可能又得重新重绘或者回流了，这就造成了一些没有必要的损耗。
所以干脆就先把DOM树的结构先解析完，把可以做的工作做完，然后等你css加载完之后，
在根据最终的样式来渲染render树，这种做法性能方面确实会比较好一点。


## 普通图层和复合图层以及CSS动画 和js 实现动画的性能对比
> 脱离文档流

* float布局 absolute 、fixed 定位等会造成脱离文档流
> 普通文档流（也是复合图层，但是会造成render进程的GUI线程回流和重绘） 和复合图层

1. 普通文档流可以理解为一个复合图层
2. absolute fixed 虽然可以脱离文档流，但它仍然属于默认图层
3. 可以通过硬件加速的方式，声明一个新的复合图层，它会单独分配资源，当然也会脱离文档流，这样的话，不管这个复合图层怎么变化，也不会影响默认复合图层的回流重绘
4. GPU中，各个图层是单独绘制的，所以互不影响，这也是为什么某些场景硬件加速效果非常好
5. 可以Chrome源码调试 -> More Tools -> Rendering -> Layer borders中看到，黄色的就是复合图层信息

> 默认图层和复合图层 

渲染步骤中就提到了composite概念。
可以简单的这样理解，浏览器渲染的图层一般包含两大类：普通图层以及复合图层
首先，普通文档流内可以理解为一个复合图层（这里称为默认复合层，里面不管添加多少元素，其实都是在同一个复合图层中）
其次，absolute布局（fixed也一样），虽然可以脱离普通文档流，但它仍然属于默认复合层。
然后，可以通过硬件加速的方式，声明一个新的复合图层，它会单独分配资源
（当然也会脱离普通文档流，这样一来，不管这个复合图层中怎么变化，也不会影响默认复合层里的回流重绘）
可以简单理解下：GPU中，各个复合图层是单独绘制的，所以互不影响，这也是为什么某些场景硬件加速效果一级棒
可以Chrome源码调试 -> More Tools -> Rendering -> Layer borders中看到，黄色的就是复合图层信息

> 如何变成复合图层（硬件加速）或者 CPU、GPU和硬件加速（GPU加速）

* 硬件加速就是创建了一个被传递到GPU处理的层的操作，这个层就是复合图层，
* 创建复核图层就是
    * 最常用的方式：translate3d、translateZ
    * opacity属性/过渡动画（需要动画执行的过程中才会创建合成层，动画没有开始或结束后元素还会回到之前的状态）
    * will-chang属性（这个比较偏僻），一般配合opacity与translate使用（而且经测试，除了上述可以引发硬件加速的属性外，其它属性并不会变成
    * 浏览器将a元素提升为一个复合层有很多种原因，下面列举了一些：
        * 3d或透视变换css属性，例如translate3d,translateZ等等（js一般通过这种方式，使元素获得复合层）
        * <video><iframe><canvas><webgl>等元素。
        * 混合插件（如flash）。
        * 元素自身的 opacity和transform 做 CSS 动画。
        * 拥有css过滤器的元素。
        * 使用will-change属性。
        * position:fixed。
        * 元素有一个 z-index 较低且包含一个复合层的兄弟元素(换句话说就是该元素在复合层上面渲染)

>> 什么是硬件加速

* 硬件加速意味着Graphics Processing Unit（GPU）会通过代替Central Processing Unit (CPU)做一些负荷比较大的事情，来协助浏览器快速渲染页面，当CSS操作使用硬件加速的时候，通常会使页面渲染速度加快，但如果不合理运用硬件加速，会影响电池寿命。todo
* GPU处理来加速。除了opacity能够使用GPU处理的就是CSS 3D变形了
* 很长一段时间内我们都通过translateZ()或者translate3d() hack来骗取浏览器触发硬件加速，具体做法就是为元素添加没有变化的3D变形，比如元素在2维空间可以通过添加以下CSS来硬件加速transform: translate3d(0, 0, 0);
复合层）
> 仅仅只发生GPU 的合成composite 不触发回流reflow和重绘repaint，我们做动画的css property必须满足以下三个条件：

        不影响文档流。
        不依赖文档流。
        不会造成重绘。
注意：position 会造成 回流和重绘，满足以上以上条件的css property只有transform和opacity。

> will-change属性的解释

* 3D 变换是被动迫使转换到GPU，而will-chang是主动来通知浏览器留意接下来的变化，从而优化和分配内存，允许对浏览器默认样式的优化如何提前处理因素，在动画实际开始之前，为准备动画执行潜在昂贵的工作著作权归作者所有。这明显比之前说的3D hacks要好。
* will-change属性可以提前通知浏览器我们要对元素做什么动画，这样浏览器可以提前准备合适的优化设置。这样可以避免对页面响应速度有重要影响的昂贵成本。元素可以更快的被改变，渲染的也更快，这样页面可以快速更新，表现的更加流畅。
* 举个例子，当对于素使用 CSS 3D变形时，元素及其内容可以在合成到页面之前被创建到我们之前说的layer。然而把元素放到layer中是个昂贵的操作，这将会导致变形动画延迟一个课件的瞬间，也就是flicker
* 为了避免这种延时，我们可以在发生之前通知浏览器，这样浏览器会有一定的时间去准备这些变化，当发生的时候layer已经准备好了，这样动画酒会很流畅，不会闪屏
* will-change属性的值
    * auto 表示没有明确的意图; 无论是启发式和最优化，用户代理应该应用都和正常情况相同
    * scroll-position 表示开发者期望去在接下来去改变或者有动画应用元素的滚动位置
  *  contents 表示开发者期望去在接下来去改变或者有动画应用元素的内容
* 用来排除关键字 will-change, none, all, auto, scroll-position, and contents, 从之外增加一些通用的关键字
        will-change： transform：
        will-change： opacity：
        will-change： top, left, bottom, right;

> 下面是一些针对reflow和repaint的最佳实践：

* 不要一条一条地修改dom的样式，尽量使用className一次修改。
* 将dom离线后修改
    * 使用documentFragment对象在内存里操作dom。
    * 先把dom节点display:none;（会触发一次reflow）。然后做大量的修改后，再把它显示出来
    * clone一个dom节点在内存里，修改之后；与在线的节点相替换。
* 不要使用table布局，一个小改动会造成整个table的重新布局。
* transform和opacity只会引起合成，不会引起布局和重绘。

从上述的最佳实践中你可能发现，动画优化一般都是尽可能地减少reflow、repaint的发生。关于哪些属性会引起reflow、repaint及composite，你可以在这个网站找到https://csstriggers.com/。

> CSS动画 和js 实现动画的性能对比

    用css动画而不是js动画
css动画有一个重要的特性，它是完全工作在GPU上。因为你声明了一个动画如何开始和如何结束，浏览器会在动画开始前准备好所有需要的指令；并把它们发送给GPU。而如果使用js动画，浏览器必须计算每一帧的状态；为了保证平滑的动画，我们必须在浏览器主线程计算新状态；把它们发送给GPU至少60次每秒。除了计算和发送数据比css动画要慢，主线程的负载也会影响动画； 当主线程的计算任务过多时，会造成动画的延迟、卡顿。

所以尽可能地使用基于css的动画，不仅仅更快；也不会被大量的js计算所阻塞。
[哪些属性会引起reflow、repaint及composite，你可以在这个网站找到：https://csstriggers.com/](https://csstriggers.com/)

## 从Event Loop 谈JS的运行机制以及从 macrotask 和 microtask 谈Event Loop 

* JS分为同步任务和异步任务
* 同步任务在JS引擎主线程上执行，形成一个执行栈
* JS引擎主线程之外，事件触发线程管理者一个任务队列，只要异步任务有了运行结果，就在任务队列中放置一个事件
* 一旦执行栈中的所有同步任务执行完毕，就会主动读取微任务队列，将可运行的异步任务添加到可执行栈中，开始执行，会把当前帧内所有的微任务队列中的任务全部执行
* 然后开始渲染，渲染结束后以及在下一帧开始之前都是浏览器的空闲时间（此阶段是requestIdleCallback的回调执行时间）
* 下一帧开始
* 上一帧遗留的宏任务

> macrotask 和 microtask 

* macrotask（又称之为宏任务），可以理解是每次执行栈执行的代码就是一个宏任务（包括每次从事件队列中获取一个事件回调并放到执行栈中执行）
    * 每一个task会从头到尾将这个任务执行完毕，不会执行其它
    * 浏览器为了能够使得JS内部task与DOM任务能够有序的执行，会在一个task执行结束后，在下一个 task 执行开始前，对页面进行重新渲染
    宏任务->所有微任务->渲染->宏任务
* microtask（又称为微任务），可以理解是在当前 task 执行结束后立即执行的任务
    * 微任务通常来说就是需要在当前 task 执行结束后立即执行的任务，比如对一系列动作做出反馈，或或者是需要异步的执行任务而又不需要分配一个新的 task，这样便可以减小一点性能的开销。 
    * 也就是说，在当前task任务后，下一个task之前，在渲染之前
    * 所以它的响应速度相比setTimeout（setTimeout是task）会更快，因为无需等渲染
    * 也就是说，在某一个macrotask执行完后，就会将在它执行期间产生的所有microtask都执行完毕（在渲染前）
    * 假如在上一帧的渲染过程中产生来微任务，在下一帧开始的时候是先执行一个宏任务，然后才会执行上一帧渲染阶段产生的微任务,查看总结中微任务执行的时间点
todo 图

> 总结：

* 所有同源窗口会共享一个event loop以同步通信。event loop会一直运行，来执行进入队列的宏任务。
* 宏任务按顺序执行，且浏览器在每个宏任务之间渲染页面
* 所有微任务也按顺序执行，且在以下场景会立即执行所有微任务
    * 每个回调之后且js执行栈中为空。
    * 每个宏任务结束后。
* 微任务是在当前帧内执行的，宏任务是在下一次的帧执行的，微任务一定是在宏任务前执行
* 主代码块、setTimeout而不是setInterval，注意定时器设置0ms ，本意是0毫秒后就推入事件队列中，但是W3C在HTML标准中规定，规定要求setTimeout中低于4ms的时间间隔算为4ms。
* promise 和promise.nextTick 属于微任务，在node环境promise.nextTick比 promise 先执行
* 而且setInterval有一些比较致命的问题就是：累计效应（上面提到的），如果setInterval代码在（setInterval）再次添加到队列之前还没有完成执行，就会导致定时器代码连续运行好几次，而之间没有间隔
*  所以，鉴于这么多但问题，目前一般认为的最佳方案是：用setTimeout模拟setInterval，或者特殊场合直接用requestAnimationFrame
* JS高程中有提到，JS引擎会对setInterval进行优化，如果当前事件队列中有setInterval的回调，不会重复添加。不过，仍然是有很多问题。。。
注意，有一些浏览器执行结果不一样（因为它们可能把microtask当成macrotask来执行了），因为promises 来自于ECMAScript 的标准而不是HTML标准。但是为了简单，这里不描述一些不标准的浏览器下的场景（但记住，有些浏览器可能并不标准）

## 从帧(16.6ms优化)的角度分析浏览器空闲时间
> 概念
帧：简单的理解帧就是为视频或者动画中的每一张画面，而视频和动画特效就是由无数张画面组合而成，每一张画面都是一帧。

帧数其实就是为帧生成数量的简称，可以解释为静止画面的数量，也就是说，如果一个动画的帧率恒定为 60 帧每秒(fps)，那么它在一秒钟内的帧数为 60 帧

帧率（FPS，即Frame Per Second，帧/秒）。帧率(Frame rate) = 帧数(Frames)/时间(Time)，每秒显示帧数
FPS 也可以理解为我们常说的“刷新频率”或者“刷新率”，使用“赫兹”（ Hz）为单位。
显示器有一个概念叫做刷新率（Windows系统在控制面板，显示里设置），是指在1秒内，重新刷新屏幕的次数。

通俗来说，帧率是用来衡量显卡渲染能力的一个指标。显卡在处理图像数据时，性能越强的显卡，在均等时间内（比如1秒），渲染出的静态图像的数量（这一幅静态图像就称为一帧）。一幅一幅的静态图像按顺序以一定的速度出现在我们面前，由于人眼具有的视觉暂留特性，使得我们感觉画面里的物体似乎在运动，也就形成了动画（和典型的动画片一个原理）。如果在一定时间内出现在我们眼前的静态画面越多（帧率越高），我们就感觉画面越流畅。性能强悍的显卡可以在一秒内渲染更多的帧，画面也自然越流畅，其FPS指标自然就高。

现在的显卡通常可以将CS的帧率渲染到120以上，即120FPS。可通常我们使用的显示器只能达到60HZ的刷新率。显然，即使显卡在1秒内将画面变化了120次，但显示器只有展示其中60幅的能力。这种时候，我们感知的流畅度其实是60FPS。会丢帧
显卡性能稍弱，在某些时候只能达到30FPS左右的帧率时，是怎样的呢？显示器的刷新率是固定的，无论显卡帧率如何，一定会按照其固有的刷新率更新画面，如果显卡帧率是30，显示器刷新率是60HZ，其实每一秒我们看到的画面还是更新了60次，不过其中一些更新，画面没有任何变化罢了（通俗的例子，帧率30，显示器会把显卡渲染出的一帧在屏幕上刷新两次，同一帧刷两次，2帧画面自然一致，我们感觉画面似乎没变）。画面重复即卡顿

> 直观感受，不同帧率的体验：
帧率能够达到 50 ～ 60 FPS 的动画将会相当流畅，让人倍感舒适；
帧率在 30 ～ 50 FPS 之间的动画，因各人敏感程度不同，舒适度因人而异；
帧率在 30 FPS 以下的动画，让人感觉到明显的卡顿和不适感；
帧率波动很大的动画，亦会使人感觉到卡顿。

> 页面流畅与 FPS
页面是一帧一帧绘制出来的，当每秒绘制的帧数（FPS）达到 60 时，页面是流畅的，小于这个值时，用户会感觉到卡顿。

大多数浏览器刷新率为 60 次/秒,即1s 60帧，所以每一帧分到的时间是 1000/60 ≈ 16 ms。所以我们书写代码时力求不让一帧的工作量超过 16ms。
todo 图
> 一帧 浏览器做的事情

## 首屏加载时间是从哪一步到哪一步
todo 图
## 结合帧的角度和时间性能的角度分析CSS动画 和js 实现的动画
JS 动画与 CSS 动画的细微区别
对于 JS 动画而言，它们运行时的帧率即是主线程和合成线程加起来消耗的时间。对于流畅动画而言，我们希望它们每一帧的耗时保持在 16.67ms 之内;
而对于 CSS 动画而言，由于其流程不受主线程的影响，所以希望能得到合成线程的消耗的时间，而合成线程的绘制频率也反映了滚动和 CSS 动画的流程性。
上面主要想得出的一个结论是。如果我们能够知道主线程和合成线程每一帧消耗的时间，那么我们就能大致得出对应的 Web 动画的帧率。那么上面说到的 Frame Timing API 是否可以帮助我们拿到这个时间点呢。
## 在浏览器空闲时间和渲染前等时间段分析requestIdleCallback 和 requestAnimationFrame 这两个方法
## 结合React 16 中的fiber 分析浏览器空闲时间执行的requestIdleCallback







优质连接 https://mp.weixin.qq.com/s?__biz=MzU0NDU3NzM0Ng==&mid=2247483675&idx=1&sn=447b8b89b20de742a0b0d0fe6cc69896&chksm=fb7b4336cc0cca2077074a90945efc35289819d227146e3e03e2566eb655c57ebbf7a06cd3ca&scene=0&key=88007341ad887ed217d60acffb25ad5ba768c9a798cd4bc3f8e68cd319d78b27010ad7f228e66e1aea1d199a196a1f8187a4480141309bc82fb8c0d0a4b670b5677d478df3ba0a164da5583b0dd1aa42&ascene=0&uin=MjEzMTAwMzgyNQ%3D%3D&devicetype=iMac+MacBookAir7%2C1+OSX+OSX+10.12.6+build(16G29)&version=12020810&nettype=WIFI&lang=zh_CN&fontScale=100，