强缓存 协议缓存
### 本文提纲包含以下内容：
* 区分进程和线程
* 浏览器包含哪些进程
* 渲染进程（或者经常称为Render进程或者浏览器内核）包含哪些主要线程
    * 浏览器内核中包含的线程之间的关系
    * browser进程和浏览器内核的通信过程
    * 渲染进程是如何工作的
    * GUI渲染线程和js线程（或者经常称为js引擎）的互斥关系
    * js 阻塞页面加载
    * 页面卡顿的真正原因
    * 为什么JavaScript 是单线程的？
    * WebWorker 与 SharedWork
* 地址栏回车后的所有一系列的过程分析（牵扯到浏览器顶层的部分不必死磕）
* css加载是否会阻塞dom树渲染？
* 普通图层和复合图层以及CSS动画 和js 实现动画的性能对比
* 从Event Loop 谈JS的运行机制
* 从 macrotask 和 microtask 谈Event Loop 
* 从帧(16.6ms优化)的角度分析浏览器空闲时间
* 首屏加载时间是从哪一步到哪一步
* 结合帧的角度和时间性能的角度分析CSS动画 和js 实现的动画
* 在浏览器空闲时间和渲染前等时间段分析requestIdleCallback 和 requestAnimationFrame 这两个方法
* 结合React 16 中的fiber 分析浏览器空闲时间执行的requestIdleCallback

## 区分进程和线程
1. 进程是CPU资源分配的最小单位（是能拥有资源和独立运行的最小单位）
2. 线程是CPU调度的最小单位（线程是建立在进程的基础上的一次程序运行单位，一个进程可以有多个线程）
注意：
* 不同进程之间也可以通信，不过代价较大
* 现在一般通用的叫法：单线程和多线程，都是指在一个进程内的单和多

## 浏览器包含哪些进程
* 浏览器是多进程的
* 浏览器之所以能够运行，是因为系统给它的进程分配了资源（cpu和内存）
* 简单理解，每打开一个tab页，就相当于创建了一个独立的浏览器进程，可以通过打开任务管理器仅从查看验证,也可以通过Chrome的更多工具-> 任务管理器进行验证
<div align='center'>
<image src='' width=50%>
</div>

注意：
1. 在这里浏览器应该有自己的优化机制，有时候打开多个tab页后，可以在Chrome任务管理器中看到，但有些进程被合并了（所以每一个tab标签对应一个进程并不一定是绝对的）
2. 浏览器多进程

优点： 1.某一渲染进程出问题不会影响其他的进程
      2.更为安全，在系统层面上限定了不同进程的权限 
      3.避免单个page crash 或者第三方插件影响整个浏览器
      4.多进程充分利用多核优势
      5.方便使用沙盒模型隔离插件等进程，提高浏览器稳定性

到底包含了哪些进程（为了简化理解，仅列举主要进程）
    Browser进程：也称为主控进程、主进程，浏览器的主要进程（负责协调、主控），只有一个，
        作用如下（了解，不必死磕）
            * 包括地址栏，书签栏
            * 负责浏览器的一些不可见的底层操作，比如网络请求和文件访问等
            * 负责浏览器与用户的交互，如前进。后退等
            * 将页面绘制出来
            * 负责各个页面的管理、创建和销毁其他进程等
            * 将Render进程得到的内存中的Bitmap绘制到用户界面上
            * 网络资源的管理，下载等
        我们知道浏览器 Tab 外的工作主要由 Browser Process 掌控，Browser Process 又对这些工作进一步划分，使用不同线程进行处理：  
            * UI thread ： 控制浏览器上的按钮及输入框；
            * network thread: 处理网络请求，从网上获取数据；storage 
            * thread: 控制文件等的访问；

    第三方插件进程：每种类型的插件对应一个进程，仅当使用该插件时才创建

    GPU进程：最多一个用于3D绘制和显示页面，
        仅当GPU硬件加速打开的时候才会被创建，主要用于对3D图形加速调用的实现（联想css动画和js动画性能对
        ）； 

    浏览器渲染进程(浏览器内核、Render进程、呈现引擎)：内部是多线程，默认每个Tab页面是一个进程，互不影响，以下是主要的线程：
        排版线程 compositor thread  合成器将页面分成磁贴，
        光栅线程 Raster thread      栅格线程格化磁贴存储在GPU显存中
        GUI线程
            * 负责渲染浏览器界面，解析html css 构建DOM书和RenderObject树，布局和绘制等
            * 当界面需要重绘Repaint或者由于某种操作引发的回流reflow，该线程就会执行
            * 注意，GUI 渲染线程和JS引擎线程是互斥的，当JS引擎执行时GUI线程会被挂起（相当于被冻结），GUI更新会被保存在一个队列中等待JS引擎空闲时立即被执行。（联想requestIdleCallback回掉执行的时间超时影响的后果）
        JS引擎线程
            * 也称为JavaScript解释器、JS内核，负责处理javascript脚本程序（例如V8引擎）
            * 解释器、编译器的区别，解释器是直接解析并将代码运行结果输出
            * JS引擎线程负责解析JavaScript脚本，运行代码
            * 一个Tab页（Render进程）中无论什么时候都只有一个JS线程在运行JS程序
            * 注意，GUI 渲染线程和JS引擎线程是互斥的，所以JS引擎执行时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞。（联想requestIdleCallback回掉执行的时间超时影响的后果）
            * 内部在维护一个任务队列
        事件触发线程
            * 归属于浏览器内核而不是JS引擎，用来控制事件循环
            * 当JS引擎执行代码如setTimeOut或者来自浏览器内核的其他线程，如鼠标点击、AJAX异步请求等，会将对应任务添加到事件线程中
            * 当对应的事件符合触发条件时，该线程会把事件添加到待处理队列的队尾，等待JS引擎的处理
            * 注意，由于JS引擎的单线程的关系，所以这些待处理队列中的事件都等排队等待JS引擎的处理，当JS引擎空闲时才会去执行
        定时器触发线程
            * setTimeOut 和 setInterval 所在的线程
            * 浏览器定时计数器并不是由JS引擎计数的，因为JS引擎是单线程的，如果处于阻塞线程状态就会影响计时的准确性
            * 因此通过单独的线程来计时并触发定时，计时完毕后，添加到事件队列中，等待JS引擎空闲后执行
            * 注意，W3C HTMl 标准中规定，规定要求setTimeOut 中低于4ms 的时间间隔算为4ms
        Networking 异步http请求线程
            * 在XMLHttpRequest 在连接后是通过浏览器新开一个线程请求
            * 检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更事件，将这个回调再放入事件队列中，再由JS引擎执行
todo 图
> browser进程和Renderer进程（浏览器内核）的通信过程
    1. Browser进程收到用户请求，首先UI线程处理，转交给IO线程，随后通过RendererHost接口转交给Renderer进程
    2. Renderer进程的Renderer接口收到消息，IO线程简单处理后，交给渲染线程，进行HTML解析和DOM树构建，CSS解析，JS执行，RenderObject树构建，布局和绘制等过程，生成用户可见区域（ViewPort）的Bitmap。最后通过共享内存方式IPC给Browser进程
    3. Browser进程使用Bitmap内存在界面上绘制出图像。
> 渲染进程是如何工作的
渲染进程的核心目的在于转换HTML CSS JS 为用户可交互的web页面
    解析DOM树 构建 DOM树 CSS加载解析，
    JS执行
    RenderObject树构建
    layout  布局 回流reflow  ->布局树 只包含页面可见元素
    paint   绘制 重绘 repaint ->绘制记录
    合成帧   优点：其工作无关主线程
        排版线程 compositor thread  合成器将页面分成磁贴，
            合成器的优点在于，其工作无关主线程，合成器线程不需要等待样式计算或者 JS 执行，这就是为什么合成器相关的动画 最流畅，如果某个动画涉及到布局或者绘制的调整，就会涉及到主线程的重新计算，自然会慢很多。
        光栅线程 Raster thread      栅格线程格化磁贴存储在GPU显存中（享内存）
        一旦磁贴被光栅化，合成器线程会收集称为绘制四边形的磁贴信息以创建合成帧（Bitmap）。
不同呈现引擎在主流程中会有稍微不同，例如css样式表的解析时机，在webkit 内核 html和css 的解析是同步的
todo 图片

事件循环
> GUI渲染线程与JS引擎线程互斥
1. 由于JavaScript是可操作DOM的，如果在修改这些元素属性同时渲染界面（即JS线程和UI线程同时运行）那么渲染线程前后获得的元素数据就可能不一致来
2. 因此为了防止渲染出现不可预期的结果，浏览器设置GUI渲染线程与JS引擎为互斥关系，当JS引擎执行时GUI线程会被挂起，GUI更新则会被保存在一个队列中等待JS引擎线程空闲时立即被执行
> JS阻塞页面加载
1. 从上述的互斥关系，可以推导出，如果JS执行时间过长就会阻塞页面。
2. 譬如，假设JS引擎正在进行巨量计算，此时就算GUI有更新，也会被保存到队列中，等待JS引擎空闲后执行，然后由于巨量计算，随意JS引擎很可能很久之后才能空闲，自然会感觉到巨卡无比，所以，要尽量避免JS执行时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞的感觉（联想requestIdleCallback回掉执行的时间超时影响的后果）
> 页面卡顿的真正原因
1. 由于 JavaScript 是可操纵 DOM 的，如果在修改这些元素属性同时渲染界面（即 JavaScript 线程和 UI 线程同时运行），那么渲染线程前后获得的元素数据就可能不一致了。为了防止渲染出现不可预期的结果，浏览器设置 UI 渲染线程与 JavaScript 引擎线程为互斥的关系，当 JavaScript 引擎线程执行时 UI 渲染线程会被挂起，UI 更新会被保存在一个队列中等到 JavaScript 引擎线程空闲时立即被执行。

2. 于是，我们便明白了：假设一个 JavaScript 代码执行的时间过长，这样就会造成页面的渲染不连贯，导致页面渲染出现“加载阻塞”的现象。当然，针对 DOM 的大量操作也会造成页面出现卡顿现象，毕竟我们经常说：DOM 天生就很慢。

3. 所以，当你需要考虑性能优化时就可以从如上的原因出发，大致有以下几个努力的方面：
    * 减少 JavaScript 加载对 DOM 渲染的影响（将 JavaScript 代码的加载逻辑放在 HTML 文件的尾部，减少对渲染引擎呈现工作的影响）；
    * 避免重排，减少重绘（避免白屏，或者交互过程中的卡顿）；
    * 减少 DOM 的层级（可以减少渲染引擎工作过程中的计算量）；
    * 使用 requestAnimationFrame 来实现视觉变化（一般来说我们会使用 setTimeout 或 setInterval 来执行动画之类的视觉变化，但这种做法的问题是，回调将在帧中的某个时点运行，可能刚好在末尾，而这可能经常会使我们丢失帧，导致卡顿）；
    有关优化的方面可以查看《 优化 JavaScript 执行》一文了解更多信息。
> 为什么JavaScript 是单线程的？
否则会带来很复杂的同步问题，比如，假定 JavaScript 同时有两个线程，一个线程在某个 DOM 节点上添加内容，另一个线程删除了这个节点，这时浏览器应该以哪个线程为准？当然我们可以通过锁来解决上面的问题。但为了避免因为引入了锁而带来更大的复杂性，从一诞生，JavaScript 就是单线程，这已经成了这门语言的核心特征。
> WebWorker 与 SharedWork
为了利用多核 CPU 的计算能力，在 HTML5 中引入的工作线程使得浏览器端的 JavaScript 引擎可以并发地执行 JavaScript 代码，从而实现了对浏览器端多线程编程的良好支持。Web Worker 允许 JavaScript 脚本创建多个线程，但是子线程完全受主线程控制，且不得操作 DOM 。所以，这个新标准并没有改变 JavaScript 单线程的本质。
1. 前文提到提到的JS引擎是单线程的，而且JS执行时间过长会阻塞页面，那么JS就真的对CPU密集型计算无能为力吗？所以后来HTML5中支持来Web Worker
2. MDN 官方解释：
    Web Worker为Web内容在后台线程中运行脚本提供了一种简单的方法。线程可以执行任务而不干扰用户界面，一个worker是使用一个构造函数创建的一个对象(eg:Worker()) 运行一个命名的JavaScript文件,这个文件包含将在工作线程中运行的代码; workers 运行在另一个全局上下文中,不同于当前的window,因此，使用 window快捷方式获取当前全局的范围 (而不是self) 在一个 Worker 内将返回错误
3. JS引擎线程与worker线程间通过特定的方式通信（postMessage API，需要通过序列化对象来与线程交互特定的数据）,相当于给JS引擎开了一个外挂
4. 所以如果有非常耗时的工作，单独开一个Worker线程，这样里面不管如何都不会影响JS引擎线程，只等待出结果后，将结果通信给S引擎线程即可
5. WebWorker只属于某个页面，不会和其他页面的Render进程（浏览器内核进程）共享
6. 所以Chrome在Render进程中（每一个Tab页就是一个render进程）创建一个新的线程来运行Worker中的JavaScript程序。
7. SharedWorker是浏览器所有页面共享的，不能采用与Worker同样的方式实现，因为它不隶属于某个Render进程，可以为多个Render进程共享使用
8. 所以Chrome浏览器为SharedWorker单独创建一个进程来运行JavaScript程序，在浏览器中每个相同的JavaScript只存在一个SharedWorker进程，不管它被创建多少次。
看到这里，应该就很容易明白了，本质上就是进程和线程的区别。SharedWorker由独立的进程管理，WebWorker只是属于render进程下的一个线程

## 地址栏回车后的所有一系列的过程分析（牵扯到浏览器顶层的部分不必死磕）
    大多数人使用 Chrome 最多的场景就是在地址栏输入关键字进行搜索或者输入地址导航到某个网站，我们来看看浏览器是怎么看待这个过程的。
参考连接：https://www.jianshu.com/p/5a52f2492759
## css加载是否会阻塞dom树渲染？
这里说的是头部引入css的情况
首先，我们都知道：css是由单独的下载线程异步下载的。
然后再说下几个现象：
    1. css加载不会阻塞DOM树解析（异步加载时DOM照常构建）
    2. 但会阻塞render树渲染（渲染时需等css加载完毕，因为render树需要css信息）
这可能也是浏览器的一种优化机制。
因为你加载css的时候，可能会修改下面DOM节点的样式，
如果css加载不阻塞render树渲染的话，那么当css加载完之后，
render树可能又得重新重绘或者回流了，这就造成了一些没有必要的损耗。
所以干脆就先把DOM树的结构先解析完，把可以做的工作做完，然后等你css加载完之后，
在根据最终的样式来渲染render树，这种做法性能方面确实会比较好一点。


## 普通图层和复合图层以及CSS动画 和js 实现动画的性能对比 todo 举例子 css
> 脱离文档流 todo
> 普通文档流（也是复合图层，但是会造成render进程的GUI线程回流和重绘） 和复合图层
1. 普通文档流可以理解为一个复合图层
2. absolute fixed 虽然可以脱离文档流，但它仍然属于默认图层
3. 可以通过硬件加速的方式，声明一个新的复合图层，它会单独分配资源，当然也会脱离文档流，这样的话，不管这个复合图层怎么变化，也不会影响默认复合图层的回流重绘
4. GPU中，各个图层是单独绘制的，所以互不影响，这也是为什么某些场景硬件加速效果非常好
5. 可以Chrome源码调试 -> More Tools -> Rendering -> Layer borders中看到，黄色的就是复合图层信息
> 如何变成复合图层（硬件加速）
1. 最常用的方式：translate3d、translateZ
2. opacity属性/过渡动画（需要动画执行的过程中才会创建合成层，动画没有开始或结束后元素还会回到之前的状态）
3. will-chang属性（这个比较偏僻），一般配合opacity与translate使用（而且经测试，除了上述可以引发硬件加速的属性外，其它属性并不会变成复合层），
## 从Event Loop 谈JS的运行机制以及从 macrotask 和 microtask 谈Event Loop 
* JS分为同步任务和异步任务
* 同步任务在JS引擎主线程上执行，形成一个执行栈
* JS引擎主线程之外，事件触发线程管理者一个任务队列，只要异步任务有了运行结果，就在任务队列中放置一个事件
* 一旦执行栈中的所有同步任务执行完毕，就会主动读取微任务队列，将可运行的异步任务添加到可执行栈中，开始执行，会把当前帧内所有的微任务队列中的任务全部执行
* 然后开始渲染，渲染结束后以及在下一帧开始之前都是浏览器的空闲时间（此阶段是requestIdleCallback的回调执行时间）
* 下一帧开始
* 上一帧遗留的宏任务

> macrotask 和 microtask 

* macrotask（又称之为宏任务），可以理解是每次执行栈执行的代码就是一个宏任务（包括每次从事件队列中获取一个事件回调并放到执行栈中执行）
    * 每一个task会从头到尾将这个任务执行完毕，不会执行其它
    * 浏览器为了能够使得JS内部task与DOM任务能够有序的执行，会在一个task执行结束后，在下一个 task 执行开始前，对页面进行重新渲染
    宏任务->所有微任务->渲染->宏任务
* microtask（又称为微任务），可以理解是在当前 task 执行结束后立即执行的任务
    * 微任务通常来说就是需要在当前 task 执行结束后立即执行的任务，比如对一系列动作做出反馈，或或者是需要异步的执行任务而又不需要分配一个新的 task，这样便可以减小一点性能的开销。 
    * 也就是说，在当前task任务后，下一个task之前，在渲染之前
    * 所以它的响应速度相比setTimeout（setTimeout是task）会更快，因为无需等渲染
    * 也就是说，在某一个macrotask执行完后，就会将在它执行期间产生的所有microtask都执行完毕（在渲染前）
    * 假如在上一帧的渲染过程中产生来微任务，在下一帧开始的时候是先执行一个宏任务，然后才会执行上一帧渲染阶段产生的微任务,查看总结中微任务执行的时间点
todo 图
> 总结：
* 所有同源窗口会共享一个event loop以同步通信。event loop会一直运行，来执行进入队列的宏任务。
* 宏任务按顺序执行，且浏览器在每个宏任务之间渲染页面
* 所有微任务也按顺序执行，且在以下场景会立即执行所有微任务
    * 每个回调之后且js执行栈中为空。
    * 每个宏任务结束后。
* 微任务是在当前帧内执行的，宏任务是在下一次的帧执行的，微任务一定是在宏任务前执行
* 主代码块、setTimeout而不是setInterval，注意定时器设置0ms ，本意是0毫秒后就推入事件队列中，但是W3C在HTML标准中规定，规定要求setTimeout中低于4ms的时间间隔算为4ms。
* promise 和promise.nextTick 属于微任务，在node环境promise.nextTick比 promise 先执行
* 而且setInterval有一些比较致命的问题就是：累计效应（上面提到的），如果setInterval代码在（setInterval）再次添加到队列之前还没有完成执行，就会导致定时器代码连续运行好几次，而之间没有间隔
*  所以，鉴于这么多但问题，目前一般认为的最佳方案是：用setTimeout模拟setInterval，或者特殊场合直接用requestAnimationFrame
* JS高程中有提到，JS引擎会对setInterval进行优化，如果当前事件队列中有setInterval的回调，不会重复添加。不过，仍然是有很多问题。。。
注意，有一些浏览器执行结果不一样（因为它们可能把microtask当成macrotask来执行了），因为promises 来自于ECMAScript 的标准而不是HTML标准。但是为了简单，这里不描述一些不标准的浏览器下的场景（但记住，有些浏览器可能并不标准）
## 从帧(16.6ms优化)的角度分析浏览器空闲时间
> 概念
帧：简单的理解帧就是为视频或者动画中的每一张画面，而视频和动画特效就是由无数张画面组合而成，每一张画面都是一帧。

帧数其实就是为帧生成数量的简称，可以解释为静止画面的数量，也就是说，如果一个动画的帧率恒定为 60 帧每秒(fps)，那么它在一秒钟内的帧数为 60 帧

帧率（FPS，即Frame Per Second，帧/秒）。帧率(Frame rate) = 帧数(Frames)/时间(Time)，每秒显示帧数
FPS 也可以理解为我们常说的“刷新频率”或者“刷新率”，使用“赫兹”（ Hz）为单位。
显示器有一个概念叫做刷新率（Windows系统在控制面板，显示里设置），是指在1秒内，重新刷新屏幕的次数。

通俗来说，帧率是用来衡量显卡渲染能力的一个指标。显卡在处理图像数据时，性能越强的显卡，在均等时间内（比如1秒），渲染出的静态图像的数量（这一幅静态图像就称为一帧）。一幅一幅的静态图像按顺序以一定的速度出现在我们面前，由于人眼具有的视觉暂留特性，使得我们感觉画面里的物体似乎在运动，也就形成了动画（和典型的动画片一个原理）。如果在一定时间内出现在我们眼前的静态画面越多（帧率越高），我们就感觉画面越流畅。性能强悍的显卡可以在一秒内渲染更多的帧，画面也自然越流畅，其FPS指标自然就高。

现在的显卡通常可以将CS的帧率渲染到120以上，即120FPS。可通常我们使用的显示器只能达到60HZ的刷新率。显然，即使显卡在1秒内将画面变化了120次，但显示器只有展示其中60幅的能力。这种时候，我们感知的流畅度其实是60FPS。会丢帧
显卡性能稍弱，在某些时候只能达到30FPS左右的帧率时，是怎样的呢？显示器的刷新率是固定的，无论显卡帧率如何，一定会按照其固有的刷新率更新画面，如果显卡帧率是30，显示器刷新率是60HZ，其实每一秒我们看到的画面还是更新了60次，不过其中一些更新，画面没有任何变化罢了（通俗的例子，帧率30，显示器会把显卡渲染出的一帧在屏幕上刷新两次，同一帧刷两次，2帧画面自然一致，我们感觉画面似乎没变）。画面重复即卡顿

> 直观感受，不同帧率的体验：
帧率能够达到 50 ～ 60 FPS 的动画将会相当流畅，让人倍感舒适；
帧率在 30 ～ 50 FPS 之间的动画，因各人敏感程度不同，舒适度因人而异；
帧率在 30 FPS 以下的动画，让人感觉到明显的卡顿和不适感；
帧率波动很大的动画，亦会使人感觉到卡顿。

> 页面流畅与 FPS
页面是一帧一帧绘制出来的，当每秒绘制的帧数（FPS）达到 60 时，页面是流畅的，小于这个值时，用户会感觉到卡顿。

大多数浏览器刷新率为 60 次/秒,即1s 60帧，所以每一帧分到的时间是 1000/60 ≈ 16 ms。所以我们书写代码时力求不让一帧的工作量超过 16ms。
todo 图

## 首屏加载时间是从哪一步到哪一步
## 结合帧的角度和时间性能的角度分析CSS动画 和js 实现的动画
JS 动画与 CSS 动画的细微区别
对于 JS 动画而言，它们运行时的帧率即是主线程和合成线程加起来消耗的时间。对于流畅动画而言，我们希望它们每一帧的耗时保持在 16.67ms 之内;

而对于 CSS 动画而言，由于其流程不受主线程的影响，所以希望能得到合成线程的消耗的时间，而合成线程的绘制频率也反映了滚动和 CSS 动画的流程性。

上面主要想得出的一个结论是。如果我们能够知道主线程和合成线程每一帧消耗的时间，那么我们就能大致得出对应的 Web 动画的帧率。那么上面说到的 Frame Timing API 是否可以帮助我们拿到这个时间点呢。
## 在浏览器空闲时间和渲染前等时间段分析requestIdleCallback 和 requestAnimationFrame 这两个方法
## 结合React 16 中的fiber 分析浏览器空闲时间执行的requestIdleCallback







优质连接 https://mp.weixin.qq.com/s?__biz=MzU0NDU3NzM0Ng==&mid=2247483675&idx=1&sn=447b8b89b20de742a0b0d0fe6cc69896&chksm=fb7b4336cc0cca2077074a90945efc35289819d227146e3e03e2566eb655c57ebbf7a06cd3ca&scene=0&key=88007341ad887ed217d60acffb25ad5ba768c9a798cd4bc3f8e68cd319d78b27010ad7f228e66e1aea1d199a196a1f8187a4480141309bc82fb8c0d0a4b670b5677d478df3ba0a164da5583b0dd1aa42&ascene=0&uin=MjEzMTAwMzgyNQ%3D%3D&devicetype=iMac+MacBookAir7%2C1+OSX+OSX+10.12.6+build(16G29)&version=12020810&nettype=WIFI&lang=zh_CN&fontScale=100，